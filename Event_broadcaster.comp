DEFINE COMPONENT Event_broadcaster
DEFINITION PARAMETERS()
SETTING PARAMETERS (
string ring = 0,
string fen = 0,
string tube = 0,
string a = 0,
string b = 0,
string tof = "t",
string ip = 0,
int port = 9000,
int broadcast = 1,
pulse_rate = 14
)
OUTPUT PARAMETERS ()
DEPENDENCY "-L. -Lbuild -lwrapper"
SHARE
%{
#include <signal.h>
#include <unistd.h> // for execve
#include <sys/time.h>
#include <stdlib.h>
#include <stdint.h>
#include "wrapper.h"

#include <unistd.h>

  void delay() {
	for (int i=0; i<300; ++i) sleep(0.1);
	}

  struct efu_time {
    uint32_t hi;
    uint32_t lo;
  };
  typedef struct efu_time efu_time_t;

  efu_time_t efu_now(){
    efu_time_t out;
    out.hi = 0;
    out.lo = 0;
    return out;
  }
  efu_time_t efu_add(efu_time_t a, efu_time_t b){
    efu_time_t out;
    out.hi = a.hi + b.hi;
    uint64_t r = (uint64_t)a.lo + (uint64_t)b.lo;
    uint64_t m = 88052499;
    if (r > m) {
      out.hi += 1u;
      r -= m;
    }
    out.lo = (uint32_t)r;
    return out;
  }
  efu_time_t efu_sub(efu_time_t a, efu_time_t b){
    efu_time_t out;
    out.hi = a.hi - b.hi;
    uint64_t r;
    if (a.lo < b.lo) {
      r = (uint64_t)a.lo - (uint64_t)b.lo;
    } else {
      out.hi -= 1u;
      r = ((uint64_t)88052499 + (uint64_t)a.lo) - (uint64_t)b.lo;
    }
    out.lo = (uint32_t)r;
    return out;
  }
  int efu_compare(efu_time_t a, efu_time_t b){
	  int out=0;
		if (a.hi > b.hi || a.hi < b.hi) {
		  out = a.hi > b.hi ? 1 : -1;
		} else if (a.lo > b.lo || a.lo < b.lo) {
		  out = a.lo > b.lo ? 1 : -1;
		}
		return out;
  }
  efu_time_t efu_from_double(double a){
    efu_time_t out;
    out.hi = (uint32_t)a;
    double r = a - (double)out.hi;
    out.lo = (uint32_t)(r * 88052499);
    return out;
  }
  efu_time_t now_in_sec_88MHz() {
    struct timeval te;
    gettimeofday(&te, NULL);
    efu_time_t out;
    out.hi = (uint32_t)te.tv_sec;
    uint64_t r = (uint64_t) te.tv_usec * (uint64_t) 88052499;
    out.lo = (uint32_t)(r/(uint64_t)(1000000));
    return out;
  }



  void throw_error(char* named, char* variable){
    printf("Event_broadcaster: %s: Particle variable %s inaccessible, exiting.\n", named, variable);
    exit(-1);
  }
  int particle_getvar_int(_class_particle* p, char* name){
      double bits = particle_getvar(p, name, 0);
      return *(int*)&bits;
  }

%}

DECLARE
%{
// pre-declare the stateful object
bifrost_readout_t* bifrost;
efu_time_t last_time;
efu_time_t repetition_time;
efu_time_t offset_time;
efu_time_t now_time;
//
int child_pid;
%}

INITIALIZE
%{
// Include the header file and run any initialization for the real broadcaster
if (ip == 0 || ip[0] == '\0'){
	bifrost = bifrost_readout_create("127.0.0.1", port);
} else {
	bifrost = bifrost_readout_create(ip, port);
}
bifrost_readout_setPulseTime(bifrost, 1, 0, 0, 0);
bifrost_readout_newPacket(bifrost);

// Make sure the provided property names are accessible -- no error checking later
int failure=0;
particle_getvar(_particle, ring, &failure);
if (failure) throw_error(NAME_CURRENT_COMP, ring);

particle_getvar(_particle, fen, &failure);
if (failure) throw_error(NAME_CURRENT_COMP, fen);

particle_getvar(_particle, tube, &failure);
if (failure) throw_error(NAME_CURRENT_COMP, tube);

particle_getvar(_particle, a, &failure);
if (failure) throw_error(NAME_CURRENT_COMP, a);

particle_getvar(_particle, b, &failure);
if (failure) throw_error(NAME_CURRENT_COMP, b);

particle_getvar(_particle, tof, &failure);
if (failure) throw_error(NAME_CURRENT_COMP, tof);

last_time = now_in_sec_88MHz();
offset_time.hi = 0;
offset_time.lo = 0;
repetition_time = efu_from_double(1/pulse_rate);

printf("pulse rate set to %"PRIu32 " %"PRIu32"\n", repetition_time.hi, repetition_time.lo);

bifrost_readout_setPulseTime(bifrost, last_time.hi, last_time.lo, 0, 0);

child_pid = fork();
if (0 == child_pid) {
  // This *is* the child, change the execution stack
	char * args[] = {NULL};
	char * envs[] = {NULL};
	execve("./waiter", args, envs);
}

%}

TRACE
%{
delay();
now_time = now_in_sec_88MHz();
/*
 * The EFU can not accept events which have decreasing event times?
 * One could try to implement a buffer that sorts event time to avoid this problem, but that seems complicated.
 * Instead, add the N*pulse-repetition-time to each event to (hopefully) avoid this issue.
*/
// offset_time = efu_add(offset_time, repetition_time);
// now_time = efu_add(now_time, offset_time);

// If the time difference exceeds the pulse-period, send the old packet, create a new one, and add the pulse times
if (efu_compare(now_time, efu_add(last_time, repetition_time)) == 1) {
  efu_time_t r = now_in_sec_88MHz();

  printf("Event_broadcaster=%s: Send packet, update time to (%"PRIu32", %"PRIu32", %"PRIu32", %"PRIu32")\n",
	       NAME_CURRENT_COMP, now_time.hi, now_time.lo, last_time.hi, last_time.lo);
  if (broadcast){
	  // TODO combine these three into a single 'flush' call?
	  bifrost_readout_send(bifrost);
		bifrost_readout_newPacket(bifrost);
	  bifrost_readout_setPulseTime(bifrost, now_time.hi, now_time.lo, last_time.hi, last_time.lo);
	}
  last_time = now_time;
}

int int_ring = particle_getvar_int(_particle, ring);
int int_fen = particle_getvar_int(_particle, fen);
int int_tube = particle_getvar_int(_particle, tube);
int int_A = particle_getvar_int(_particle, a);
int int_B = particle_getvar_int(_particle, b);

double double_tof = particle_getvar(_particle, tof, 0);

// add error checking of int -> uintN_t values?
uint8_t RING = (uint8_t)int_ring;
uint8_t FEN = (uint8_t)int_fen;
uint8_t TUBE = (uint8_t)int_tube;
uint16_t A = (uint16_t)int_A;
uint16_t B = (uint16_t)int_B;


efu_time_t efu_tof = efu_from_double(double_tof);
efu_time_t event_time = efu_add(now_time, efu_tof);

//printf("(%2u %2u %2u) %5u %5u %10u %10u -- Accumulated\n", RING, FEN, TUBE, A, B, event_time.hi, event_time.lo);

// Send the event to the broadcaster to be accumulated and broadcast
if (broadcast) bifrost_readout_add(bifrost, RING, FEN, event_time.hi, event_time.lo, TUBE, A, B);
%}

FINALLY
%{
// perform any teardown of the stateful broadcaster
if (broadcast) bifrost_readout_send(bifrost);
bifrost_readout_destroy(bifrost);

if (child_pid) {
	printf("Event_broadcaster=%s: Stopping child with pid %d\n", NAME_CURRENT_COMP, child_pid);
  // See if the child exists *and* we are allowed to ask the child to stop
	int res = kill(child_pid, 0);
	if (!res){ // no error, no-signal succeeded
	  res = kill(child_pid, SIGTERM);
		if (!kill(child_pid, 0)){
		  printf("Sent SIGTERM, waiting for wrap-up\n");
			sleep(1);
		  res = kill(child_pid, SIGTERM);
			sleep(1);
		}
		res = kill(child_pid, 0);
	}
	if (!res){ // only true if SIGTERM failed
	  res = kill(child_pid, SIGKILL);
	}
	if (!res) printf("Child with PID %d refuses to halt?\n", child_pid);
}


%}

MCDISPLAY
%{
%}

END
