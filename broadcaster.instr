DEFINE INSTRUMENT SimpleBroadcaster(
int sendPackets=0,
int reuse=0,
string address="127.0.0.1"
//"172.17.5.35"
)

DECLARE
%{
char sendTo[256];
char store_or_replay[10];

int cassette;
int analyzer;
%}

USERVARS
%{
int charge_A;
int charge_B;
int RING;
int FEN;
int TUBE;
%}

INITIALIZE
%{
if (address == 0 || address[0] == '\0'){
  strcpy(sendTo, "127.0.0.1");
} else {
  strcpy(sendTo, address);
}

strcpy(store_or_replay, (reuse ? "replay": "store"));

%}
TRACE

COMPONENT Origin = Progress_bar() AT (0,0,0) ABSOLUTE EXTEND
%{
  cassette = (int)(rand01()*9);
  analyzer = (int)(rand01()*5);
%}

COMPONENT Source = Source_simple(yheight = 0.1, xwidth = 0.1, dist = 1, focus_xw=0.1, focus_yh=0.1, E0=5, dE=4)
WHEN !reuse AT (0,0,0) RELATIVE Origin ROTATED (0,0,0) RELATIVE Origin

COMPONENT Detector = PSD_monitor(nx=100, ny=100, filename="psd.dat", xwidth=0.1, yheight=0.1)
WHEN !reuse AT (0,0,1) RELATIVE Source ROTATED (0,0,0) RELATIVE Source
EXTEND %{
// Interpretation of the digital identifiers RING, TUBE, FEN and amplitudes are
// defined together with data format and a suggestion of the full instrument
// configuration in the BIFROST ICD
// https://project.esss.dk/owncloud/index.php/s/4M60TNdqkMcppUX
if (SCATTERED) {
  RING = cassette / 3;
  TUBE = (cassette - 3*RING)*5 + analyzer;
  FEN = 0; // always 0 for BIFROST
  charge_A = (int)(rand01() * 10000);
  charge_B = (int)(rand01() * 10000);
//  printf("(%2d %2d %2d) %5d %5d\n", RING, FEN, TUBE, charge_A, charge_B);
}
%}

// Store/Retreive the particles *before* deciding if each should be used as an event.
// Then we can (re)use the same probability rays to 'fill' an event stream over time
// e.g., `mcrun broadcaster.instr -n 10000 reuse=0 sendPackets=0` to create the stored rays
//       `mcrun broadcaster.instr -n 1000000 reuse=1` to replay the 1e4 rays 100 times, creating events
COMPONENT store_events = Store_Replay(mode=store_or_replay)
AT (0,0,0) RELATIVE Origin ROTATED (0,0,0) RELATIVE Origin

//// The scale is set entirely empirically at present. Events at this point have p~=0.79
//COMPONENT to_events = Probability_to_Event(scale=2, mode="p")
//WHEN !reuse AT (0,0,0.005) RELATIVE Detector ROTATED (0,0,0) RELATIVE Detector

COMPONENT event_broadcaster = Event_broadcaster(ring="RING", fen="FEN", tube="TUBE", a="charge_A", b="charge_B", ip=sendTo, broadcast=sendPackets)
// None of the AT ... matters as the broadcaster accepts all events which have made it this far through the instrument.
AT(0,0,0) RELATIVE Detector ROTATED (0,0,0) RELATIVE Origin

FINALLY
%{
%}
END
